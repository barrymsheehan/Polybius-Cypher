package com.barrysheehan.www;

/*
 * Contains Polybius Square data and methods required to encrypt and decrypt text.
 */

public class Cypher {
	private String key;
	private char[] alphabetisedKey;
	private int[] alphabetisedKeyIndices;
	private char[] cypher = {'A', 'D', 'F', 'G', 'V', 'X'}; // Character pairs generated by matching a characters' index in matrix with same index in cypher
	private char[][] matrix = {
			{'P', 'H', '0', 'Q', 'G', '6'},
			{'4', 'M', 'E', 'A', '1', 'Y'},
			{'L', '2', 'N', 'O', 'F', 'D'},
			{'X', 'K', 'R', '3', 'C', 'V'},
			{'S', '5', 'Z', 'W', '7', 'B'},
			{'J', '9', 'U', 'T', 'I', '8'}
	};
	
	/*
	 * Set key
	 */
	public boolean setKey(String key) {
		if(key.matches("[a-zA-Z0-9]+")) { // Regex ensures key contains only letters and integers
			this.key = key.toUpperCase();
			this.alphabetisedKey = key.toUpperCase().toCharArray();
			
			/*
			 * Create instance of AlphabetiseKey() class which sorts the key alphabetically.
			 * Alphabetising the key as soon as it is input makes alphabetisedKeyIndices available for encryption and decryption.
			 */
			AlphabetiseKey sortKey = new AlphabetiseKey();
			alphabetisedKeyIndices = sortKey.getAlphabetisedKeyIndices(this.alphabetisedKey);
			return true;
		} else {
			return false;
		}	
	}
	
	public String getKey() {
		return this.key;
	}
	
	/*
	 * Encrypt text
	 */
	public String encrypt(String plainText) {
		char[][] keyTable = buildKeyTable(encryptTextWithMatrix(plainText.toUpperCase())); // Build keyTable
		String encryptedString = getEncryptedString(jumbleKeyTable(keyTable)); // Get encrypted String
		return encryptedString;
	}
	
	/*
	 * Encrypt each encryptable character in the plainText String
	 */
	private String encryptTextWithMatrix(String plainText) {
		StringBuilder sb = new StringBuilder();
		for(int i = 0; i < plainText.length(); i++) {
			if(existsInMatrix(plainText.charAt(i))) {
				sb.append(getTableEncryptedCharacters(plainText.charAt(i)));
			} else {
				sb.append(plainText.charAt(i)); // If char doesn't exist in matrix, append the plainText character directly to sb
			}
		}
		return sb.toString();
	}
	
	/*
	 * Check whether a character from plainText exists in matrix
	 */
	private boolean existsInMatrix(char charToCheck) {
		boolean exists = false;
		
		for(int row = 0; row < matrix.length; row++) {
			for(int col = 0; col < matrix[row].length; col++) {
				if(matrix[row][col] == charToCheck) {
					exists = true;
				}
			}
		}
		return exists;
	}
	
	/*
	 * Find the two appropriate characters in cypher with which to encrypt a plainText character
	 */
	private char[] getTableEncryptedCharacters(char plainChar) {
		char[] tableEncryptedCharacters = new char[2];
		
		for(int row = 0; row < matrix.length; row++) {
			for(int col = 0; col < matrix[row].length; col++) {
				if(matrix[row][col] == plainChar) {
					tableEncryptedCharacters[0] = cypher[row]; // Match character's y index to a character in cypher array at top of class
					tableEncryptedCharacters[1] = cypher[col]; // Match character's x index to a character in cypher
				}
			}
		}
		return tableEncryptedCharacters;
	}
	
	/*
	 * Create a new 2D array in which each inner array is the same length as key and a sufficient number
	 * of rows exist to hold the entire encrypted text.
	 * 
	 */
	private char[][] buildKeyTable(String tableEncryptedText) {
		int numRows = (int)(Math.ceil((double)tableEncryptedText.length() / (double)alphabetisedKey.length));
		int rowCounter = 0;
		int charCounter = 0;
		char[][] keyTable = new char[numRows][alphabetisedKey.length];
		
		while(charCounter < tableEncryptedText.length()) {
			char[] tempArray = new char[alphabetisedKey.length]; // Rows are added to keyTable one by one
			for(int i = 0; i < tempArray.length; i++) {
				/*
				 * Below if statement avoids ArrayIndexOutOfBoundsException.
				 * Remaining characters in tableEncryptedText may be fewer than a full row of keyTable.
				 */
				if(charCounter < tableEncryptedText.length()) {
					tempArray[i] = tableEncryptedText.charAt(charCounter);
					charCounter++;
				}
			}
			keyTable[rowCounter] = tempArray;
			rowCounter++;
		}
		return keyTable;
		
	}
	
	/*
	 * Rearrange each column in keyTable to match the alphabetised key
	 */
	private char[][] jumbleKeyTable(char[][] keyTable) {
		char[][] jumbledKeyTable = new char[keyTable.length][alphabetisedKeyIndices.length];
		
		for(int row = 0; row < keyTable.length; row++) {
			char[] tempArray = new char[alphabetisedKeyIndices.length];
			for(int col = 0; col < alphabetisedKeyIndices.length; col++) {
				/*
				 * Character at [col] in tempArray is assigned value of character at appropriate index in current row of keyTable.
				 * Appropriate index is defined by the value at [col] in alphabetisedKeyIndices
				 */
				tempArray[col] = keyTable[row][alphabetisedKeyIndices[col]];
			}
			jumbledKeyTable[row] = tempArray;
		}
		return jumbledKeyTable;
	}
	
	/*
	 * Convert jumbledKeyTable to the final encrypted String
	 */
	private String getEncryptedString(char[][] jumbledKeyTable) {
		StringBuilder sb = new StringBuilder();
		
		for(int col = 0; col < alphabetisedKeyIndices.length; col++) {
			for(int row = 0; row < jumbledKeyTable.length; row++) {
				sb.append(jumbledKeyTable[row][col]);
			}
		}
		return sb.toString();
	}
	
	/*
	 * Decrypt text
	 */
	public String decrypt(String encryptedText) {
		try {
			String decryptedText = decryptTextWithMatrix(unjumbleKeyTable(buildReverseKeyTable(encryptedText))); // Throws exception if encrypted text is corrupt
			return decryptedText.trim(); // Encryption / decryption processes will usually result in numerous trailing spaces. .trim() removes them
		} catch(StringIndexOutOfBoundsException sie) {
			System.out.println("\n> !ERROR: String index out of bounds.");
			return null; // If text is corrupt and can't be decrypted, return null
		} catch(ArrayIndexOutOfBoundsException aie) {
			System.out.println("\n> !ERROR: Array index out of bounds.");
			return null;
		}
	}
	
	/*
	 * Build reverseKeyTable from encryptedText
	 * Throws StringIndexOutOfBoundsException() if the text supplied to the methods
	 * contains alphanumeric characters that do not appear in the pairs expected
	 * of as defined by the Polybius Square.
	 * Exception handled in decrypt() method above
	 */
	private char[][] buildReverseKeyTable(String encryptedText) throws StringIndexOutOfBoundsException {
		int numRows = (int)(Math.ceil((double)encryptedText.length() / (double)alphabetisedKey.length));
		int charCounter = 0;
		char[][] reversedKeyTable = new char[numRows][alphabetisedKey.length];
		
		while(charCounter < encryptedText.length()) {
			for(int col = 0; col < alphabetisedKey.length; col++) {
				for(int row = 0; row < numRows; row++) {
						reversedKeyTable[row][col] = encryptedText.charAt(charCounter);
						charCounter++;
				}
			}
		}
		
		return reversedKeyTable;
	}
	
	/*
	 * Rearrange each column in reversedKeyTable to match the original order of key
	 */
	private String unjumbleKeyTable(char[][] reversedKeyTable) {
		StringBuilder sb = new StringBuilder();
		char[][] unjumbledKeyTable = new char[reversedKeyTable.length][alphabetisedKeyIndices.length];
		
		for(int row = 0; row < reversedKeyTable.length; row++) {
			char[] tempArray = new char[alphabetisedKeyIndices.length];
			for(int col = 0; col < alphabetisedKeyIndices.length; col++) {
				/*
				 * Appropriate index in tempArray is assigned value of character at current [row] and [col] indices in reversedKeyTable.
				 * Appropriate index is defined by the value at [col] in alphabetisedKeyIndices
				 */
				tempArray[alphabetisedKeyIndices[col]] = reversedKeyTable[row][col];
			}
			unjumbledKeyTable[row] = tempArray;
		}
		

		for(int row = 0; row < unjumbledKeyTable.length; row++) {
			for(int col = 0; col < unjumbledKeyTable[row].length; col++) {
				sb.append(unjumbledKeyTable[row][col]);
			}
		}
		return sb.toString();
	}
	
	/*
	 * Decrypt each decryptable character in encryptedText
	 */
	private String decryptTextWithMatrix(String encryptedText) throws ArrayIndexOutOfBoundsException {
		StringBuilder sb = new StringBuilder();
		int charCounter = 0;
		
		while(charCounter < encryptedText.length()) {
			if(existsInCypher(encryptedText.charAt(charCounter))) {
				sb.append(getDecryptedCharacter(encryptedText.charAt(charCounter), encryptedText.charAt(charCounter + 1))); // Send current character and proceeding character to getDecryptedCharacter
				charCounter += 2;
			} else {
				sb.append(encryptedText.charAt(charCounter)); // If character doesn't exist in cypher, append character directly to StringBuilder, sb
				charCounter++;
			}
		}
		return sb.toString();
	}
	
	/*
	 * Check if character exists in cypher array
	 */
	private boolean existsInCypher(char charToCheck) {
		boolean exists = false;
		for(int i = 0; i < cypher.length; i++) {
			if(charToCheck == cypher[i]) {
				return true;
			}
		}
		return exists;
	}
	
	/*
	 * Take two encrypted characters and locate the decrypted character they describe in matrix
	 * Throws ArrayIndexOutOfBoundsException when there are not two valid characters supplied to it
	 */
	private char getDecryptedCharacter(char charOne, char charTwo) throws ArrayIndexOutOfBoundsException {
		char decryptedCharacter;
		int row = -1;
		int col = -1;
		
		for(int i = 0; i < cypher.length; i++) { // Iterate over matrix
			if(charOne == cypher[i] && charTwo == cypher[i]) { // if charOne and charTwo are same character, and it exists at this index in cypher
				row = i;
				col = i;
			} else if(charOne == cypher[i]) {
				row = i;
			} else if(charTwo == cypher[i]) {
				col = i;
			}
		}
		decryptedCharacter = matrix[row][col];
		return decryptedCharacter;
	}
	
}